#import the genetic algorithm library
library(GA)

#### --- FUNCTIONS --- ####

#1.Function that parses indirect predecessors using initial data frame
findAllPredecessors <- function(task, tasks) {
  #return NULL value if the task has no immediate predecessors
  if (is.null(tasks$ImmediatePredecessors[[task]])) {
    return(NULL)
  }
  
  #assign the direct predecessors of the task to a variable
  direct_predecessors <- tasks$ImmediatePredecessors[[task]]
  #create an empty vector to store all predecessors of the task
  all_predecessors <- c()
  
  #use for loop to iterate through each indirect predecessor
  for (predecessor in direct_predecessors) {
    all_predecessors <- c(all_predecessors, predecessor, findAllPredecessors(predecessor, tasks))
  }
  
  #return only unique predecessors (remove any duplicates)
  return(unique(all_predecessors))
}

#2. Function that decodes the chromosome generated by a genetic algorithm
decode_chromosome <- function(chromosome, tasks) {
  #create lists to store workstations, their load, and tools
  workstations <- vector("list", length(chromosome))
  workstation_load <- numeric(length(chromosome))
  workstation_tools <- vector("list", length(chromosome))
  
  #create vector to keep track of assigned tasks
  assigned_tasks <- c() 
  
  # for loop through each task in the chromosome
  for (i in seq_along(chromosome)) {
    #extract the task information from the chromosome and tasks data
    task <- chromosome[i]
    task_time <- tasks$Time[task]
    task_tool <- tasks$Tool[task]
    task_predecessors <- tasks$AllPredecessors[[task]]
    
    #check if the task is already assigned to a workstation
    if (task %in% assigned_tasks) { 
      #skip to the next iteration if the task is assigned
      next
    }
    
    #create a flag variable for assigning the current task to a workstation
    assigned <- FALSE
    
    #loop through workstations to find the one that can fit the task
    for (j in seq_along(workstation_load)) {
      #check if the current workstation can accommodate 
      #the task without violating the takt time constraint  or precedence constraints
      if (workstation_load[j] + task_time <= takt_time_input &&
          (is.null(task_predecessors) || all(task_predecessors %in% unlist(workstations[1:(j-1)])))) {
        #update the workstation load, tasks, and tools for the current workstation
        workstation_load[j] <- workstation_load[j] + task_time
        workstations[[j]] <- c(workstations[[j]], task)
        workstation_tools[[j]] <- unique(c(workstation_tools[[j]], task_tool))
        #set the flag to TRUE and add the task to the assigned tasks list
        assigned <- TRUE
        assigned_tasks <- c(assigned_tasks, task)
        #break the loop because the task is assigned
        break
      }
    }
    
    #if the task cannot be assigned to any existing workstation, create a new one
    if (!assigned) {
      #evaluate the index of the first empty workstation
      first_empty_workstation <- which(sapply(workstations, is.null))[1]
      #update the workstation load, tasks, and tools for the new workstation
      workstation_load[first_empty_workstation] <- task_time
      workstations[[first_empty_workstation]] <- c(workstations[[first_empty_workstation]], task)
      workstation_tools[[first_empty_workstation]] <- task_tool
      #add the task to assigned tasks list
      assigned_tasks <- c(assigned_tasks, task)
    }
  }
  
  #calculate precedence violations at the end
  #create a counter variable for precedence violations
  precedence_violations <- 0
  #loop through each workstation and calculate precedence violations count
  for (i in seq_along(workstations)) {
    #extract the list of tasks at the current workstation
    tasks_in_workstation <- workstations[[i]]
    #loop through the tasks in the workstation
    for (task in tasks_in_workstation) {
      #get the list of all predecessors for the current task
      task_predecessors <- tasks$AllPredecessors[[task]]
      #check if any predecessor tasks are not assigned to earlier workstations
      if (!is.null(task_predecessors) && !all(task_predecessors %in% unlist(workstations[1:(i-1)]))) {
        #increase the violations counter variable by 1
        precedence_violations <- precedence_violations + 1
      }
    }
  }
  
  #remove empty workstations
  workstations <- workstations[!sapply(workstations, is.null)]
  workstation_load <- workstation_load[workstation_load > 0]
  workstation_tools <- workstation_tools[!sapply(workstation_tools, is.null)]
  
  #return multiple objects as a list
  return(list(workstations = workstations, workstation_load = workstation_load, workstation_tools = workstation_tools, precedence_violations = precedence_violations))
}

#3. Function that calculates the objective function for GA
objective_function <- function(chromosome, tasks) {
  #decode the chromosome to get the workstations, workstation_load, workstation_tools, and precedence_violations
  decoded <- decode_chromosome(chromosome, tasks)
  workstations <- decoded$workstations
  workstation_load <- decoded$workstation_load
  workstation_tools <- decoded$workstation_tools
  precedence_violations <- decoded$precedence_violations
  
  #calculate the economic score
  economic_score <- (sum(tasks$Time))/(length(workstations) * takt_time_input)
  #calculate the social score
  social_score <- (max_stdev - min( sd(workstation_load) , max_stdev )) / max_stdev
  #calculate the number of tasks that require tools
  num_tasks_req_tools <- sum(!is.na(tasks$Tool))
  #calculate the total number of tools used at all workstations
  total_number_tools_needed <- sum(sapply(workstation_tools, function(x) length(na.omit(x))))
  #calculate the environmental score
  environmental_score <- (num_tasks_req_tools-total_number_tools_needed)/(num_tasks_req_tools - 3)
  
  #multiply the scores by their weight
  economic_score_norm <- (economic_score)*weight_economic
  social_score_norm <- (social_score)*weight_social
  environmental_score_norm <- (environmental_score)*weight_environmental
  
  #add a large penalty term for violating each of the precedence constraints
  precedence_penalty <- -1000000 * precedence_violations
  
  #add a dynamic (exponential) penalty term if the number of workstations exceeds total times divided by takt time rounded up 
  min_stations <- ceiling(sum(tasks$Time)/takt_time_input)
  workstation_penalty <- ifelse(length(workstations) > min_stations, -1000 * (length(workstations) - min_stations)^2, 0)
  
  #calculate the aggregated objective value by summing up scores and penalties
  aggregated_objective_value <- ((economic_score_norm+social_score_norm+environmental_score_norm)/(weight_economic+weight_social+weight_environmental)) + precedence_penalty + workstation_penalty
  
  #return the aggregated objective value
  return(aggregated_objective_value)
}

#4. Function that prints the decoded solution in a more appealing way
print_decoded_solution <- function(decoded_best_solution) {
  cat("Workstations for each task:\n")
  for (i in seq_along(decoded_best_solution$workstations)) {
    sorted_tasks <- sort(decoded_best_solution$workstations[[i]])
    workstation_tools <- na.omit(decoded_best_solution$workstation_tools[[i]])
    workstation_takt_time <- decoded_best_solution$workstation_load[i]
    cat(paste0("Workstation ", i, ": "), sorted_tasks, "\n")
    cat(paste0("Tools at Workstation ", i, ": "), workstation_tools, "\n")
    cat(paste0("Takt time of Workstation ", i, ": "), workstation_takt_time, "\n\n")
  }
}

# 5. Helper function to check if moving a task during local search respects precedence constraints
is_move_valid <- function(task, current_workstation_index, target_workstation_index, tasks, workstations) {
  #create a temporary copy of workstations
  temp_workstations <- workstations
  #remove the task from its current workstation in the copy
  temp_workstations[[current_workstation_index]] <- setdiff(temp_workstations[[current_workstation_index]], task)
  #add the task to its target workstation in the copy
  temp_workstations[[target_workstation_index]] <- c(temp_workstations[[target_workstation_index]], task)
  
  #loop to check the precedence constraint for all tasks
  for (task_to_check in tasks$Task) {
    #get the predecessors of the current task to check
    task_predecessors <- tasks$AllPredecessors[[task_to_check]]
    #If the task has no predecessors then move to the next task
    if (is.null(task_predecessors)) {
      next
    }
    
    #find the index of the workstation where the task_to_check is currently assigned
    task_workstation_index <- which(sapply(temp_workstations, function(x) task_to_check %in% x))
    
    #loop through all the predecessor tasks
    for (predecessor in task_predecessors) {
      #find the index of the workstation to which the predecessor task is currently assigned
      predecessor_workstation_index <- which(sapply(temp_workstations, function(x) predecessor %in% x))
      
      #check if moving the task to the last workstation violates the precedence constraint
      if (target_workstation_index == length(workstations) && predecessor_workstation_index >= task_workstation_index) {
        #cat("Task", task, "move from workstation", current_workstation_index, "to workstation", target_workstation_index, "violates precedence constraint\n")
        return(FALSE)
      }
      
      #check if moving the task to a workstation other than the last one violates the precedence constraint
      if (target_workstation_index != length(workstations) && predecessor_workstation_index > task_workstation_index) {
        #cat("Task", task, "move from workstation", current_workstation_index, "to workstation", target_workstation_index, "violates precedence constraint\n")
        return(FALSE)
      }
    }
  }
  
  #cat("Task", task, "move from workstation", current_workstation_index, "to workstation", target_workstation_index, "satisfies precedence constraint\n")
  
  #return TRUE if moving the task satisfies the precedence constraints
  return(TRUE)
}

#6. Function that runs a local search on the solution found by global search 
#by moving tasks between workstations until all the feasible combinations are tested
local_search <- function(decoded_solution, tasks) {
  #initialize the best solution and best objective value from global search
  best_solution <- decoded_solution
  best_objective_value <- -Inf
  
  #calculate the initial scores for economic, social, and environmental objectives
  economic_score <- (sum(tasks$Time))/(length(best_solution$workstations) * takt_time_input)
  social_score <- (max_stdev - min( sd(best_solution$workstation_load) , max_stdev )) / max_stdev
  num_tasks_req_tools <- sum(!is.na(tasks$Tool))
  total_number_tools_needed <- sum(sapply(best_solution$workstation_tools, function(x) length(na.omit(x))))
  environmental_score <- (num_tasks_req_tools-total_number_tools_needed)/(num_tasks_req_tools - 3)
  
  economic_score_norm <- (economic_score)*weight_economic
  social_score_norm <- (social_score)*weight_social
  environmental_score_norm <- (environmental_score)*weight_environmental
  
  #update the best objective value with the calculated initial scores
  best_objective_value <- sum(c(economic_score_norm, social_score_norm, environmental_score_norm))/(weight_economic+weight_social+weight_environmental)
  
  #create the iteration counter
  iteration <- 0
  
  #while loop for the local search
  while (TRUE) {
    #create a flag variable to track improvement within an iteration
    improved_this_iteration <- FALSE
    #increase the value of the iteration counter
    iteration <- iteration + 1
    #print current iteration number
    cat("Iteration:", iteration, "\n")
    
    #generate random order of tasks for further evaluation
    task_order <- sample(tasks$Task, length(tasks$Task))
    
    #loop through the tasks in the random order
    for (task in task_order) {
      #extract the index of the current workstation for the task
      current_workstation_index <- which(sapply(best_solution$workstations, function(x) task %in% x))
      #extract the current workstation
      current_workstation <- best_solution$workstations[[current_workstation_index]]
      
      #generate a random order for target_workstation_index to evaluate
      target_workstation_order <- sample(seq_along(best_solution$workstations), length(best_solution$workstations))
      
      #loop through the target workstation indices in the random order
      for (target_workstation_index in target_workstation_order) {
        #skip iteration if the target workstation is the same as the current workstation
        if (target_workstation_index == current_workstation_index) {
          next
        }
        
        #check if moving the task respects the precedence constraints (using the helper function)
        if (!is_move_valid(task, current_workstation_index, target_workstation_index, tasks, best_solution$workstations)) {
          next
        }
        
        #check whether moving a task respects the takt time constraint
        task_time <- tasks$Time[task]
        if (best_solution$workstation_load[target_workstation_index] + task_time > takt_time_input) {
          next
        }
        
        #move the task to the target workstation and update the solution
        
        #create a temporary solution variable and assign the best_solution found so far to it
        temp_solution <- best_solution
        #remove the task from the current workstation
        temp_solution$workstations[[current_workstation_index]] <- setdiff(temp_solution$workstations[[current_workstation_index]], task)
        #add the task to the target workstation
        temp_solution$workstations[[target_workstation_index]] <- c(temp_solution$workstations[[target_workstation_index]], task)
        #decrease the workload of the current workstation
        temp_solution$workstation_load[current_workstation_index] <- temp_solution$workstation_load[current_workstation_index] - task_time
        #increase the workload of the target workstation
        temp_solution$workstation_load[target_workstation_index] <- temp_solution$workstation_load[target_workstation_index] + task_time
        
        #update the tools at the current and target workstations
        
        #extract the tools for the current workstation
        current_workstation_tools <- best_solution$workstation_tools[[current_workstation_index]]
        #extract tasks at the current workstation after task removal
        current_workstation_tasks <- temp_solution$workstations[[current_workstation_index]]
        #extract tools at the target workstation
        target_workstation_tools <- best_solution$workstation_tools[[target_workstation_index]]
        #extract the tool required by the task
        task_tool <- tasks$Tool[task]
        
        #check if the task has a tool requirement
        if (!is.na(task_tool)) {
          if (current_workstation_index != target_workstation_index) {
            #check if there are remaining tasks in the current workstation that need the moved tasks tool
            remaining_tasks_need_tool <- any(vapply(current_workstation_tasks, function(x) tasks$Tool[x] == task_tool, FUN.VALUE = logical(1), USE.NAMES = FALSE))
            
            #if there are mo remaining tasks need the tool then remove the tool from the current workstation
            if (!is.na(remaining_tasks_need_tool) && !remaining_tasks_need_tool) {
              updated_current_workstation_tools <- na.omit(setdiff(current_workstation_tools, task_tool))
              if (length(updated_current_workstation_tools) > 0) {
                temp_solution$workstation_tools[[current_workstation_index]] <- updated_current_workstation_tools
              } else {
                temp_solution$workstation_tools[[current_workstation_index]] <- NA
              }
            }
          }
          
          #add the task tool to the target workstation
          temp_solution$workstation_tools[[target_workstation_index]] <- unique(c(na.omit(target_workstation_tools), task_tool))
        }
        
        #if the current workstation is empty after performed move then remove it
        if (length(temp_solution$workstations[[current_workstation_index]]) == 0) {
          temp_solution$workstations <- temp_solution$workstations[-current_workstation_index]
          temp_solution$workstation_load <- temp_solution$workstation_load[-current_workstation_index]
          temp_solution$workstation_tools <- temp_solution$workstation_tools[-current_workstation_index]
        }
        
        #calculate the objective score for the temporary solution
        economic_score <- (sum(tasks$Time))/(length(temp_solution$workstations) * takt_time_input)
        social_score <- (max_stdev - min( sd(temp_solution$workstation_load) , max_stdev )) / max_stdev
        num_tasks_req_tools <- sum(!is.na(tasks$Tool))
        total_number_tools_needed <- sum(sapply(temp_solution$workstation_tools, function(x) length(na.omit(x))))
        environmental_score <- (num_tasks_req_tools-total_number_tools_needed)/(num_tasks_req_tools - 3)
        
        economic_score_norm <- (economic_score)*weight_economic
        social_score_norm <- (social_score)*weight_social
        environmental_score_norm <- (environmental_score)*weight_environmental
        
        current_objective_value <- sum(c(economic_score_norm, social_score_norm, environmental_score_norm))/(weight_economic+weight_social+weight_environmental)
        
        #if the new solution is better, update the best solution and objective values
        if (current_objective_value > best_objective_value) {
          best_solution <- temp_solution 
          best_objective_value <- current_objective_value
          improved_this_iteration <- TRUE
          best_solution_ws_count <- length(temp_solution$workstations)
          best_solution_sd <- sd(temp_solution$workstation_load)
          best_solution_tools_count <- sum(sapply(temp_solution$workstation_tools, function(x) length(na.omit(x))))
          best_solution_weighted_sum <- current_objective_value
          best_solution_econ_score <- economic_score_norm
          best_solution_social_score <- social_score_norm
          best_solution_envir_score <- environmental_score_norm
          
          #if the solution is improved, print out the information about this solution
          cat("Moved task", task, "from workstation", current_workstation_index, "to workstation", target_workstation_index, "\n")
          cat('Weighted Sum:', current_objective_value, 'economic:',  economic_score_norm, 'social:', social_score_norm, 'envir:', environmental_score_norm, "\n")
          cat('WS count:', best_solution_ws_count, 'SD:', best_solution_sd, 'Tools:', best_solution_tools_count, "\n")
          break
        }
      }
      
      #if there was an improvement in this iteration then exit the loop
      if (improved_this_iteration) {
        break
      }
    }
    
    #if there was no improvement in this iteration then stop the search
    if (!improved_this_iteration) {
      cat("Local search completed\n")
      #create the output list with the information about the best solution found
      output <- list(
        best_solution = best_solution,
        current_objective_value = best_solution_weighted_sum,
        economic_score_norm = best_solution_econ_score,
        social_score_norm = best_solution_social_score,
        environmental_score_norm = best_solution_envir_score,
        workstation_count = best_solution_ws_count,
        sd_workstation_load = best_solution_sd,
        sum_tools = best_solution_tools_count
      )
      #return the list with the information about the best solution found
      return(output)
    }
  }
}

#7. Function that runs local search n number of times and collects the results to a dataframe
run_iterations <- function(n = 100, decoded_solution, tasks) {
  #create an empty data frame to store the results of each iteration of local search
  results <- data.frame(iteration = integer(),
                        current_objective_value = numeric(),
                        economic_score_norm = numeric(),
                        social_score_norm = numeric(),
                        environmental_score_norm = numeric(),
                        workstation_count = integer(),
                        sd_workstation_load = numeric(),
                        sum_tools = integer())
  
  #create a list to store the best solutions found in each iteration
  best_solutions <- vector("list", n)
  
  #loop through for n iterations
  for (i in 1:n) {
    cat("Running iteration", i, "\n")
    result <- local_search(decoded_solution, tasks)
    result_row <- data.frame(iteration = i,
                             current_objective_value = result$current_objective_value,
                             economic_score_norm = result$economic_score_norm,
                             social_score_norm = result$social_score_norm,
                             environmental_score_norm = result$environmental_score_norm,
                             workstation_count = result$workstation_count,
                             sd_workstation_load = result$sd_workstation_load,
                             sum_tools = result$sum_tools)
    #add the current result row to a data frame
    results <- rbind(results, result_row)
    #save the best solution found in this iteration to the list
    best_solutions[[i]] <- result$best_solution
  }
  #return the results df and the best_solutions list
  return(list(results = results, best_solutions = best_solutions))
}

#### INPUTS ####

#define the inputs of the problem
takt_time_input <- 40
max_stdev <- 25
weight_economic <- 7
weight_social <- 9
weight_environmental <- 5

#create the initial data frame with tasks data
tasks <- data.frame(
  Task = 1:30,
  Time = c(11, 14, 5, 6, 10, 10, 8, 10, 7, 5, 11, 10, 14, 5, 8, 14, 10, 6, 9, 6, 9, 5, 13, 15, 10, 8, 6, 13, 10, 7),
  Tool = c(NA, NA, NA, 'M2', 'M3', NA, 'M3', 'M3', 'M1', NA, NA, 'M2', NA, 'M3', NA, 'M2', NA, 'M1', NA, 'M1', 'M1', NA, 'M3', 'M3', NA, 'M3', 'M1', 'M3', 'M3', 'M1')
)

#define the list of immediate predecessor tasks
ImmediatePredecessors <- list(
  NULL,
  NULL,
  c(1),
  c(2),
  NULL,
  c(3),
  c(4),
  c(4, 5),
  c(2),
  c(6),
  c(6, 7),
  c(7),
  c(8),
  c(10, 11),
  c(11, 12),
  c(13, 15),
  c(9, 13),
  c(14, 15),
  c(15),
  c(16, 19),
  c(17),
  c(18),
  c(18, 19),
  c(20),
  c(20, 21),
  c(22, 23),
  c(23, 24, 26),
  c(24, 25),
  c(26, 27, 28),
  c(29)
)
#add the list to the data frame
tasks$ImmediatePredecessors <- ImmediatePredecessors
#find all the predecessors by applying the function
tasks$AllPredecessors <- lapply(tasks$Task, findAllPredecessors, tasks = tasks)

#define the lower and upper bounds for the decision variables
lower_bounds <- rep(1, length(tasks$Task))
upper_bounds <- rep(30, length(tasks$Task))

#### GLOBAL SEARCH ####

#run the GA permutation algorithm for 10000 iterations with population size 100,
#mutation probability 15%, and always carry on 10 best solutions to the next epoch
#parallel processing is enabled to speed up the algorithm
result <- ga(type = "permutation",
             fitness = function(chromosome) objective_function(chromosome, tasks),
             lower = lower_bounds, upper = upper_bounds,
             popSize = 100, maxiter = 10000, pmutation = 0.15,
             elitism = 10, parallel = TRUE)

#extract the best solution
best_solution <- result@solution
#print the best objective function value
cat("Best objective function value:", result@fitnessValue, "\n")
#print out the decoded best solution 
decoded_best_solution <- decode_chromosome(best_solution, tasks)
print_decoded_solution(decoded_best_solution)

#### LOCAL SEARCH ####

#run the local search iteratively
results_and_solutions <- run_iterations(100, decoded_best_solution, tasks)

#extract results data frame and best solutions list
results_df <- results_and_solutions$results
best_solutions_list <- results_and_solutions$best_solutions

#display the best solution out of all conducted local searches
max(results_df$current_objective_value)
best_solutions_list[which.max(results_df$current_objective_value)]


